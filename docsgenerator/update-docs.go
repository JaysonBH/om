package main

import (
	"fmt"
	"github.com/onsi/gomega/gexec"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

const (
	ReadmeFileName         = "README.md"
	ReadmeTemplate         = "<!--- This file is autogenerated from the files in docsgenerator/templates/%s file --->\n&larr; [back to Commands](../README.md)\n\n# `om %s`\n\n%s\n\n## Command Usage\n```\n%s```\n\n%s"
	DescriptionFileName    = "EXPANDED_DESCRIPTION.md"
	DescriptionTemplate    = "<!--- Anything in this file will be used instead of the default command description in the final docs/%s/README.md file --->"
	additionalInfoFileName = "ADDITIONAL_INFO.md"
	AdditionalInfoTemplate = "<!--- Anything in this file will be appended to the final docs/%s/README.md file --->"
)

func main() {
	omPath, err := gexec.Build("../main.go", "-ldflags", "-X main.applySleepDurationString=1ms -X github.com/pivotal-cf/om/commands.pivnetHost=http://example.com")
	if err != nil {
		fmt.Printf("could not build binary: %s\n", err)
		os.Exit(1)
	}

	err = execute(omPath)
	if err != nil {
		fmt.Printf("could not update docs: %s\n", err)
		os.Exit(1)
	}
}

func execute(omPath string) error {
	templateDir, err := filepath.Abs("templates/")
	if err != nil {
		return err
	}

	docsDir, err := filepath.Abs("../docs/")
	if err != nil {
		return err
	}

	commandNames, err := getCommandNames(omPath)
	if err != nil {
		return err
	}

	err = createTemplateDirs(templateDir, commandNames)
	if err != nil {
		return err
	}

	err = generateDocs(omPath, templateDir, docsDir)
	if err != nil {
		return err
	}

	return nil
}

func createTemplateDirs(templatesPath string, commands []string) error {
	templateDirs, err := getDirectoryContents(templatesPath, true)
	if err != nil {
		return err
	}

	for _, command := range commands {
		err = os.Mkdir(filepath.Join(templatesPath, command), 0755)
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		commandTemplateDir := filepath.Join(templatesPath, command)

		err := createCommandTemplates(command, commandTemplateDir, map[string]string{
			additionalInfoFileName: AdditionalInfoTemplate,
			DescriptionFileName:    DescriptionTemplate,
		})
		if err != nil {
			return err
		}

		fmt.Printf("Added %s templates at: docsgenerator%s\n", command, strings.Split(commandTemplateDir, "docsgenerator")[1])
	}

	for _, templateDir := range templateDirs {
		var commandExists bool
		for _, command := range commands {
			if strings.Contains(templateDir, command) {
				commandExists = true
			}
		}

		if !commandExists {
			err := os.RemoveAll(templateDir)
			if err != nil {
				return err
			}

			fmt.Printf("Removed templates at: docsgenerator/templates%s\n", strings.Split(templateDir, "templates")[1])
		}
	}

	return nil
}

func generateDocs(omPath string, templatesPath string, docsDir string) error {
	templateDirs, err := getDirectoryContents(templatesPath, true)
	if err != nil {
		return err
	}

	for _, templateDir := range templateDirs {
		commandName := filepath.Base(templateDir)

		descriptionContents, err := getFileContents(filepath.Join(templateDir, DescriptionFileName))
		if err != nil {
			return err
		}

		additionalInfoContents, err := getFileContents(filepath.Join(templateDir, additionalInfoFileName))
		if err != nil {
			return err
		}

		err = os.Mkdir(filepath.Join(docsDir, commandName), 0755)
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		f, err := os.Create(filepath.Join(docsDir, commandName, ReadmeFileName))
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		if len(strings.Split(descriptionContents, "\n")) == 1 && descriptionContents == fmt.Sprintf(DescriptionTemplate, commandName) {
			descriptionContents, err = getDescription(omPath, commandName)
			if err != nil {
				return err
			}
		}

		if len(strings.Split(additionalInfoContents, "\n")) == 1 && additionalInfoContents == fmt.Sprintf(AdditionalInfoTemplate, commandName) {
			additionalInfoContents = ""
		}

		usage, err := runShellCommand(".", omPath, commandName, "--help")
		if err != nil {
			return err
		}

		_, err = f.Write([]byte(fmt.Sprintf(ReadmeTemplate, commandName, commandName, descriptionContents, usage, additionalInfoContents)))
		if err != nil {
			return err
		}

		err = f.Close()
		if err != nil {
			return err
		}
	}

	return nil
}

func getFileContents(filepath string) (string, error) {
	contents, err := ioutil.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return string(contents), nil
}

func getDirectoryContents(templatesPath string, onlyDirectories bool) ([]string, error) {
	var templateDirs []string
	err := filepath.Walk(templatesPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if path == templatesPath {
			return nil
		}

		if !onlyDirectories || info.IsDir() {
			templateDirs = append(templateDirs, path)
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return templateDirs, nil
}

func createCommandTemplates(command string, commandTemplateDir string, fileTemplates map[string]string) error {
	for fileName, template := range fileTemplates {
		f, err := os.Create(filepath.Join(commandTemplateDir, fileName))
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		if template != "" {
			_, err = f.Write([]byte(fmt.Sprintf(template, command)))
			if err != nil {
				return err
			}

			err = f.Close()
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func getDescription(omPath string, commandName string) (string, error) {
	output, err := runShellCommand(".", omPath, commandName, "--help")
	if err != nil {
		return "", err
	}

	return strings.Split(string(output), "\n")[1], nil
}

func getCommandNames(omPath string) ([]string, error) {
	output, err := runShellCommand(".", omPath, "--help")
	if err != nil {
		return nil, err
	}

	outputLines := strings.Split(string(output), "\n")

	var isCommand bool
	var commands []string
	for _, commandLine := range outputLines {
		if strings.Contains(commandLine, "Commands:") && !isCommand {
			isCommand = true
			continue
		}

		if isCommand && commandLine != "" {
			splitCommandLine := strings.Fields(commandLine)
			commands = append(commands, splitCommandLine[0])
		}
	}

	return commands, nil
}

func runShellCommand(dir, cmd string, args ...string) ([]byte, error) {
	command := exec.Command(cmd, args...)
	command.Dir = dir
	return command.Output()
}
